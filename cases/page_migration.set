#!1 BACKEND: hugetlb_anon
#!1 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!1 BACKGROUND: none
#!1 OVERCOMMIT: overcommit noovercommit
#!1 RESERVE: reserve noreserve

#!2 BACKEND: hugetlb_anon
#!2 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!2 BACKGROUND: reserve
#!2 OVERCOMMIT: overcommit noovercommit
#!2 RESERVE: reserve noreserve

#!3 BACKEND: hugetlb_anon
#!3 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!3 BACKGROUND: allocate0 allocate1
#!3 OVERCOMMIT: overcommit noovercommit

#!4 BACKEND: hugetlb_anon
#!4 MIGRATE_SRC: hotremove

#!5 BACKEND: thp
#!5 MIGRATE_SRC: migratepages hotremove move_pages madv_soft mbind
#!5 BACKGROUND: none
#!5 BUSY: busy idle

. $TRDIR/setup_page_migration.sh

MIGRATE_SRC=__MARK_MIGRATE_SRC
BACKEND=__MARK_BACKEND
BACKGROUND=__MARK_BACKGROUND
BUSY=__MARK_BUSY

if [ "$BUSY" == busy ] ; then
	BUSYOPT=-b
fi

NUMA_NODE=2
HUGEPAGESIZE=2048 # kB

if [[ "$BACKEND" =~ hugetlb ]] ; then
	HUGETLB=100
	if [ __MARK_OVERCOMMIT == overcommit ] ; then
		HUGETLB_OVERCOMMIT=10
	fi
	if [ __MARK_RESERVE == noreserve ] ; then
		NORESERVEFLAG=-R
	fi
elif [[ "$BACKEND" =~ thp ]] ; then
	THP=true
fi

TEST_PROGRAM="$test_alloc_generic -o page_migration -s $MIGRATE_SRC -B $BACKEND -d work -N 2 $NORESERVEFLAG $BUSYOPT"

if [ "$BACKGROUND" == reserve ] ; then
	RESERVE_HUGEPAGE=$[HUGETLB - 2]
	if [ __MARK_OVERCOMMIT == overcommit ] ; then
		EXPECTED_RETURN_CODE="SET_OVERCOMMIT RESERVE START MIGRATION_PASSED EXIT"
	else
		EXPECTED_RETURN_CODE="RESERVE START MIGRATION_FAILED EXIT"
	fi
elif [ "$BACKGROUND" == allocate0 ] ; then
	ALLOCATE_HUGEPAGE=$[HUGETLB - 2]
	ALLOCATE_NODE=0
	if [ __MARK_OVERCOMMIT == overcommit ] ; then
		# in 2 node system, if background thread eats up all hugepages on
		# node 0, TEST_PROGRAM cannot help using node 1 before migration.
		# In such a case, page migration never succeeds, even if overcommit
		# is enabled.
		# ... but mbind somehow succeed in such case :(, let's make it
		# failed until situation is understood.
		EXPECTED_RETURN_CODE="SET_OVERCOMMIT ALLOCATE START MIGRATION_FAILED EXIT"
	else
		EXPECTED_RETURN_CODE="ALLOCATE START MIGRATION_FAILED EXIT"
	fi
elif [ "$BACKGROUND" == allocate1 ] ; then
	ALLOCATE_HUGEPAGE=$[HUGETLB - 2]
	ALLOCATE_NODE=1
	if [ __MARK_OVERCOMMIT == overcommit ] ; then
		EXPECTED_RETURN_CODE="SET_OVERCOMMIT ALLOCATE START MIGRATION_PASSED EXIT"
	else
		EXPECTED_RETURN_CODE="ALLOCATE START MIGRATION_FAILED EXIT"
	fi
else
	if [ __MARK_OVERCOMMIT == overcommit ] ; then
		EXPECTED_RETURN_CODE="SET_OVERCOMMIT START MIGRATION_PASSED EXIT"
	else
		EXPECTED_RETURN_CODE="START MIGRATION_PASSED EXIT"
	fi
fi

if [ "$MIGRATE_SRC" == hotremove ] ; then
	if [[ "$BACKEND" =~ hugetlb ]] ; then
		HUGETLB=$[$MEMTOTAL/$HUGEPAGESIZE/2]
		HUGETLB_ALLOCATED=$[HUGETLB*4/5]
		# no pass fail ?
		TEST_PROGRAM="$test_alloc_generic -o page_migration -s $MIGRATE_SRC -B $BACKEND -d work -N $HUGETLB_ALLOCATED -M $(get_backend_pageflags hugetlb_mapped) $BUSYOPT"
	elif [[ "$BACKEND" =~ thp ]] ; then
		THP=$[$MEMTOTAL/$HUGEPAGESIZE/2]
		THP_ALLOCATED=$[THP*4/5]
		TEST_PROGRAM="$test_alloc_generic -o page_migration -s $MIGRATE_SRC -B $BACKEND -d work -N $THP_ALLOCATED -M $(get_backend_pageflags $BACKEND) $BUSYOPT"
	fi
fi
