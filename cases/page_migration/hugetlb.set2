#!1 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!1 BACKGROUND: reserve
#!1 OVERCOMMIT: overcommit noovercommit

# "allocate0 + noovercommit" case is meaningless testcases because test program
# always fail to allocate hugepage from node 0 and killed by SIGBUS before trying
# to page migration.

#!2 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!2 BACKGROUND: allocate0 allocate1
#!2 OVERCOMMIT: overcommit

#!3 MIGRATE_SRC: migratepages mbind move_pages madv_soft
#!3 BACKGROUND: allocate1
#!3 OVERCOMMIT: noovercommit

. $TRDIR/lib/setup_page_migration.sh

# In older kernel (< 4.15), if the hugepage pool of destination node is fully
# used, hugepage migraion fails due to ENOMEM. But in newer kernels, hugepage
# migration succeeds even in such a situation, so let the testcase know that.
# CONFIG_EXPECTED_BEHAVIOR_HUGEPAGE_MIGRATION=true means that the kernel is
# supposed to have the newer behavior. Otherwise, the test expects the older
# behavior.
CONFIG_HUGEPAGE_MIGRATION_EXPECTED_NEWER_BEHAVIOR=true

BACKEND=hugetlb_anon
MIGRATE_SRC=__STR_MIGRATE_SRC
BACKGROUND=__STR_BACKGROUND
OPERATION_SRC=__STR_OPERATION_SRC
NUMA_NODE=2
HUGEPAGESIZE=2048 # kB

EXPECTED_RETURN_CODE=""

PIPETIMEOUT=20

HUGETLB=100
#if __MARK_OVERCOMMIT == __MARK_OVERCOMMIT_overcommit
HUGETLB_OVERCOMMIT=10
EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE SET_OVERCOMMIT"
#endif

#if __MARK_BACKGROUND == __MARK_BACKGROUND_reserve
EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE RESERVE"
RESERVE_HUGEPAGE=$[HUGETLB - 2]
#elif __MARK_BACKGROUND == __MARK_BACKGROUND_allocate0
ALLOCATE_HUGEPAGE=$[HUGETLB - 2]
ALLOCATE_NODE=0
EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE ALLOCATE"
#elif __MARK_BACKGROUND == __MARK_BACKGROUND_allocate1
# allocate
ALLOCATE_HUGEPAGE=$[HUGETLB - 2]
ALLOCATE_NODE=1
EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE ALLOCATE"
#endif

EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE START"

if [ "$CONFIG_HUGEPAGE_MIGRATION_EXPECTED_NEWER_BEHAVIOR" == true ] ; then
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_PASSED HUGEPAGE_MIGRATED"
elif [ "$BACKGROUND" == reserve ] ; then
	#if __MARK_OVERCOMMIT == __MARK_OVERCOMMIT_overcommit
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_PASSED HUGEPAGE_MIGRATED"
	#else
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_FAILED HUGEPAGE_NOT_MIGRATED"
	#fi
elif [ "$BACKGROUND" == allocate0 ] || [ "$BACKGROUND" == allocate1 ] ; then
	#if __MARK_OVERCOMMIT == __MARK_OVERCOMMIT_overcommit
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_PASSED HUGEPAGE_MIGRATED"
	#else
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_FAILED HUGEPAGE_NOT_MIGRATED"
	#fi
else
	EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE MIGRATION_PASSED HUGEPAGE_MIGRATED"
fi

EXPECTED_RETURN_CODE="$EXPECTED_RETURN_CODE EXIT"

TEST_PROGRAM="lib/test_alloc_generic -B $BACKEND -N 2 -L 'start:wait_after mmap_numa:preferred_cpu_node=0:preferred_mem_node=0 access:wait_after $MIGRATE_SRC munmap:wait_before exit:wait_before'"
