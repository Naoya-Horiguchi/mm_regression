KERNEL_SRC=/src/linux-dev
. test_core/lib/common.sh
. setup_sample_test.sh

DEFAULT_TEST_PREPARE=prepare_sample
DEFAULT_TEST_CLEANUP=cleanup_sample

DEFAULT_TEST_CONTROLLER=control_sample
DEFAULT_TEST_CHECKER=check_sample

TEST_TITLE='sample_test'
TEST_PROGRAM="$test_sample -m private -n1"
EXPECTED_RETURN_CODE="START EXIT"
do_test_sync

TEST_TITLE='sample_test_2'
TEST_PROGRAM="$test_sample -h 2048 -m private -n1"
EXPECTED_RETURN_CODE="START EXIT"
do_test_sync

TEST_TITLE='sample_async_test'
TEST_CONTROLLER=control_sample_async
TEST_CHECKER=check_sample_async
EXPECTED_RETURN_CODE="START SOME_TEST_CODE"
do_test_async

TEST_TITLE='sample_test_under_devel'
TEST_FLAGS=devel
TEST_PROGRAM="$test_sample -m private -n1"
EXPECTED_RETURN_CODE="START EXIT"
do_test_sync

TEST_TITLE='sample_test_false_negative'
FALSENEGATIVE=true
TEST_PROGRAM="$test_sample -m private -n1"
EXPECTED_RETURN_CODE="START NEVER_HAPPEN EXIT"
TEST_CHECKER=check_sample_false_negative
do_test_sync
FALSENEGATIVE=false

#!EMBED: cases/sample_test_case_separate_file

TEST_TITLE='sample_test_skipped'
TEST_PREPARE=prepare_sample_test_skipped
TEST_CONTROLLER=control_sample_test_skipped
TEST_CHECKER=check_sample_test_skipped
EXPECTED_RETURN_CODE="RETURN_CODE_SHOULD_NOT_BE_CHECKED"
do_test_async

# This testcase is an example where test case is not run because the current
# kernel doesn't contain the patch which should make the test pass. IOW,
# the environment variable ... is used to automatically avoid the known failure.
#
TEST_TITLE='sample_test_skipped_unfixed'
TEST_PREPARE=prepare_sample_test_skipped_unfixed
TEST_CONTROLLER=control_sample_test_skipped_unfixed
EXPECTED_RETURN_CODE="RETURN_CODE_SHOULD_NOT_BE_CHECKED"
# If you define CURRENT_KERNEL, use it as current kernel instead of $(uname -r)
CURRENT_KERNEL=v3.19
FIXEDBY_SUBJECT="mm: hwpoison: drop lru_add_drain_all() in __soft_offline_page()"
FIXEDBY_COMMITID=9ab3b598d2df
do_test_async
